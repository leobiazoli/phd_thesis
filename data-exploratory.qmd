---
title: "Exploratory data analysis"
bibliography: references.bib
editor_options: 
  chunk_output_type: console
format:
  html:
    code-fold: true
    code-tools: true
---

```{r}
#| echo: false
#| message: false
library(tidyverse)
library(readr)
library(dplyr)
library(lubridate)
library(tidyr)
library(stringr)
library(kableExtra)
library(rmarkdown)
library(tibble)
library(DescTools)
library(kableExtra)
library(readxl)
```

## Introduction

This stage includes exploratory data analysis (EDA) with the aim of analyzing and investigating the data set and summarizing its main characteristics.

```{r}
#| echo: false
load(file = "data_final_up.rda")
```

-   **Base dimension:** `r nrow(data_final_up)` rows and `r ncol(data_final_up)` columns
-   **Number of authors:** `r n_distinct(data_final_up$author_id)`
-   **Number of publications:** `r n_distinct(data_final_up$eid)`
-   **Time:** `r min(data_final_up$publication_year)` to `r max(data_final_up$publication_year)`

```{r}
#| echo: false
# view database (3.345.650 obs of 26 vars)
paged_table(data_final_up)
```

As análises descritivas serão realizadas para o período de 2005 a 2020 para investigar as subáreas do conhecimento (elas estão disponíveis apenas para este período).

```{r}
areas <- read_excel("areas_370681.xlsx") |>
  select(eid, AGRI, BIOC, DENT, HEAL, IMMU, MEDI, MULT, NEUR, NURS, PHAR, VETE) |>
  distinct()

data_proj <- data_final_up |>
  filter(publication_year >= 2005) |>
  left_join(areas)
```

## Data analysis

First, statistics were found for all the authors, without considering the academic mobility groups and then considering them by groups.

-   **Average publications per author:**

```{r}
# mean of articles by author (considering repeated publications)
mean_publication <- data_proj |>
  select(author_id, eid) |>
  group_by(author_id) |>
  summarise(
    n_publication = n_distinct(eid)
  ) |> summarise(mean_publication = mean(n_publication))
round(mean_publication[[1]],digits = 2)
```

-   **Distribution of publications by author:**

```{r}
data_proj |>
  select(author_id, eid) |>
  group_by(author_id) |>
  summarise(
    n_publication = n_distinct(eid)) |>
  ggplot(aes(x = n_publication)) +
  geom_histogram(binwidth = 5, color = "navy", alpha = 0.7, position = "dodge") +
  labs(
    x = "Number of Publications",
    y = "Frequency") +
  theme_classic()
```

-   **Distribution of publications by year:**

```{r}
data_proj |>
  group_by(publication_year) |>
  summarise(articles = n_distinct(eid)) |>
  ggplot(aes(x = publication_year, y = articles)) +
  geom_bar(stat = "identity", fill = "navy") +  
  labs(x = "Publication year", 
       y = "Number of articles") +
  theme_classic()
```

-   **Distribution of authors and articles by year:**

```{r}
data_proj |>
  group_by(publication_year) |>
  summarise(articles = n_distinct(eid),
            authors = n_distinct(author_id)) |>
  ggplot(aes(x = publication_year)) +
  # Adicionar as linhas com legenda
  geom_line(aes(y = articles, color = "Number of articles"), linewidth = 1) + 
  geom_line(aes(y = authors, color = "Number of authors"), linewidth = 1) +
  # Personalizar rótulos
  scale_color_manual(values = c("Number of articles" = "navy", 
                                "Number of authors" = "darkgray")) +
  labs(x = "Publication year", 
       y = "Count",
       color = "") + # Título da legenda
  theme_classic()
```

```{r}
# Criar faixas simplificadas de número de publicações até >100
data_proj2 <- data_proj |>
  filter(groups_c != "0") |> # sem o grupo de 1 pub
  group_by(author_id) |>
  summarise(num_publications = n_distinct(eid), .groups = "drop") |>  # Número de publicações por autor
  left_join(data_proj, by = "author_id") |>  # Reanexar informações originais
  mutate(
    pub_range = case_when(
      num_publications <= 5 ~ "5",
      num_publications <= 10 ~ "10",
      num_publications <= 15 ~ "15",
      num_publications <= 20 ~ "20",
      num_publications <= 25 ~ "25",
      num_publications <= 30 ~ "30",
      num_publications <= 35 ~ "35",
      num_publications <= 40 ~ "40",
      num_publications <= 45 ~ "45",
      num_publications <= 50 ~ "50",
      num_publications <= 55 ~ "55",
      num_publications <= 60 ~ "60",
      num_publications <= 65 ~ "65",
      num_publications <= 70 ~ "70",
      num_publications <= 75 ~ "75",
      num_publications <= 80 ~ "80",
      num_publications <= 85 ~ "85",
      num_publications <= 90 ~ "90",
      num_publications <= 95 ~ "95",
      num_publications <= 100 ~ "100",
      TRUE ~ "100+"
    )
  )

# Garantir a ordem correta das faixas
data_proj2 <- data_proj2 |> 
  mutate(pub_range = factor(pub_range, levels = c("5", "10", "15", "20", "25", "30", "35", "40", 
                                                  "45", "50", "55", "60", "65", "70", "75", "80", 
                                                  "85", "90", "95", "100", "100+")))

# Agrupar os dados e calcular a proporção por grupo
data_grouped <- data_proj2 |>
  group_by(pub_range, groups_c) |>
  summarise(count = n(), .groups = "drop") |>  # Contar ocorrências por faixa e grupo
  group_by(pub_range) |>  # Normalizar para 100% dentro de cada faixa
  mutate(proportion = count / sum(count) * 100) |> 
  ungroup()

# Mapear os grupos para nomes específicos
group_labels <- c(
  `1` = "non-migrant",
  `2` = "immigrant",
  `3` = "emigrant",
  `4` = "return migrant",
  `5` = "transient"
)

# Criar o gráfico de barras empilhadas com tons de cinza
ggplot(data_grouped, aes(x = pub_range, y = proportion, fill = as.factor(groups_c))) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(
    values = rev(gray.colors(5)),  # Tons de cinza
    labels = group_labels,    # Rótulos personalizados
    name = ""  # Título da legenda
  ) +
  labs(
    x = "Number of Publications",
    y = "Percentage of Researchers"
  ) +
  theme_classic() +
  scale_y_continuous(labels = scales::percent_format(scale = 1)) +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5, size = 7),
        legend.position = "bottom")

```

```{r}
# Calcular o número de autores por faixa de publicação
data_authors <- data_proj2 |>
  group_by(pub_range) |>
  summarise(num_authors = n_distinct(author_id), .groups = "drop")

# Criar o gráfico
ggplot() +
  # Barras empilhadas
  geom_bar(
    data = data_grouped,
    aes(x = pub_range, y = proportion, fill = as.factor(groups_c)),
    stat = "identity", position = "stack"
  ) +
  # Linha representando o número de autores
  geom_line(
    data = data_authors,
    aes(x = pub_range, y = num_authors / max(num_authors) * 100, group = 1),
    color = "red", size = 1
  ) +
  # Escala de cores e nomes dos grupos
  scale_fill_manual(
    values = rev(gray.colors(5)),  # Inverte para começar no tom mais claro
    labels = group_labels,         # Rótulos personalizados
    name = "Researcher Groups"     # Título da legenda
  ) +
  # Configuração dos eixos
  scale_y_continuous(
    name = "Percentage",
    sec.axis = sec_axis(~ . * max(data_authors$num_authors) / 100, name = "Number of Authors")
  ) +
  labs(
    x = "Number of Publications (Range)"
  ) +
  theme_classic() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),  # Inclinar rótulos do eixo X
    axis.title.y.right = element_text(color = "black")  # Cor do eixo secundário
  )

```


-   **Top 10 Journals:**

```{r}
data_proj |> 
  distinct(eid, publicationName_sjr) |>
  count(publicationName_sjr, sort = TRUE) |>
  drop_na() |> 
  head(10) |> 
  ggplot(aes(x = reorder(publicationName_sjr, n), y = n)) +
  geom_bar(stat = "identity", fill = "navy", color = "black", alpha = 0.7) +
  labs(
    x = "",
    y = "Frequency") +
  coord_flip() +
  theme_classic()
  
# mode_by_journal_top10 <- data_proj |>
#   group_by(publicationName_sjr) |>  # Agrupar por revista
#   summarise(
#     mode_group_c = groups_c |> 
#       table() |>                    # Criar uma tabela de frequências
#       which.max() |>                # Encontrar o índice do valor mais frequente
#       names(),                      # Pegar o nome do índice (o valor de `group_c`)
#     .groups = "drop"
#   ) |> arrange(desc(mode_group_c)) |> view()
```

-   **Citation by year:**

```{r}
data_proj |>
  #filter(groups_c %in% c(2,3,4)) |>
  ggplot(aes(x = as.factor(publication_year), y = cit_standard)) +
  geom_boxplot(fill = "lightblue", color = "darkblue", outlier.color = "red",
               outlier.size = 2) +
  labs(x = "Publication Year",
        y = "Citations") +
  theme_classic()
```

-   **Twenty most common countries of academic origin (a) and academic destination (b)**

```{r}
# first country by author
data_proj |>
  arrange(author_id, publication_year) |>
  group_by(author_id) |>
  filter(!is.na(country_year_pub)) |> # drop group 0
  summarise(
    first_country = first(country_year_pub),
    last_country = last(country_year_pub)
  ) |>
  ungroup() |>
  filter(first_country != "Brazil") |> # retira Brazil
  count(first_country, sort = T) |>
  head(20) |>
  ggplot(aes(x = reorder(first_country, n), y = n)) +
  geom_bar(stat = "identity", fill = "darkgrey", color = "black", alpha = 0.7) +
  #geom_text(aes(label = n), hjust = -0.2) +
  labs(
    #title = "(a) academic origin",
    x = "",
    y = "Frequency") +
  coord_flip() +
  theme_classic()
```

```{r}
# last country by author
data_proj |>
  arrange(author_id, publication_year) |>
  group_by(author_id) |>
  filter(groups_c != "0") |>
  summarise(
    first_country = first(country_year_pub),
    last_country = last(country_year_pub)
  ) |>
  ungroup() |>
  filter(last_country != "Brazil") |> # retira Brazil
  count(last_country, sort = T) |>
  head(20) |>  #view()
  ggplot(aes(x = reorder(last_country, n), y = n)) +
  geom_bar(stat = "identity", fill = "darkgrey", color = "black", alpha = 0.7) +
  #geom_text(aes(label = n), hjust = -0.2) +
  labs(
    #title = "(b) academic destination",
    x = "",
    y = "Frequency") +
  coord_flip() +
  theme_classic()
```

-   **Descriptive statistics by author:**
    1.  Total publications (`n_articles`)
    2.  Total citations (`n_citations`)
    3.  Total number of countries by author (`n_countries`)
    4.  Average number of citations (`mean_citation`)
    5.  Max of citations (`max_citation`)
    6.  Author group (`groups_c`)
    7.  Number of international collaboration (`collab`)

```{r}
data_proj |>
  group_by(author_id, publication_year) |>
  summarise(
    n_articles = n_distinct(eid),
    n_citations = sum(cit_standard),
    n_countries = n_distinct(country_year_pub),
    mean_citation = mean(cit_standard),
    max_citation = max(cit_standard),
    groups = unique(groups_c),
    collab = sum(foreign_country)
  ) |> 
  paged_table()
```

## Data analysis by academic mobility group

Descriptive statistics of authors with publications from 2005 to 2020 in Brazil by groups of migratory movements (the groups were defined in Step 3 in Data Organization[^1]):

[^1]: Classification of authors into groups:

    0)  single article researcher;
    1)  non-migrant researcher;
    2)  immigrant researcher;
    3)  emigrant researcher;
    4)  returning migrant researcher;
    5)  transient migrant researcher.

<!-- -->

**(1) General statistics for bibliometric indicators**

```{r}
data_proj |>
  group_by(groups_c) |>
  summarise(
    mean_citation = round(mean(cit_standard), 2),
    sd_citation = round(sd(cit_standard), 2),
    mean_sjr = round(mean(SJR, na.rm = T), 2),
    sd_sjr = round(sd(SJR, na.rm = T), 2),
    n_articles = n_distinct(eid),
    n = n_distinct(author_id)
  ) |> 
  mutate(group_label = case_when(
    groups_c == '0' ~ 'Single article',
    groups_c == '1' ~ 'Non-migrant',
    groups_c == '2' ~ 'Immigrant',
    groups_c == '3' ~ 'Emigrant',
    groups_c == '4' ~ 'Returning migrant',
    TRUE ~ 'Transient migrant'
  )) |>
  paged_table()

data_proj |>
  group_by(author_id, groups_c) |>
  summarise(collab = sum(foreign_country)) |>
  ungroup() |>
  group_by(groups_c) |>
  summarise(mean_collab = round(mean(collab),2),
            sd_collab = round(sd(collab),2)) |> 
  mutate(group_label = case_when(
    groups_c == '0' ~ 'Single article',
    groups_c == '1' ~ 'Non-migrant',
    groups_c == '2' ~ 'Immigrant',
    groups_c == '3' ~ 'Emigrant',
    groups_c == '4' ~ 'Returning migrant',
    TRUE ~ 'Transient migrant'
  )) |>
  paged_table()
```

**(2) Frequency of authors by group**

```{r}
data_proj |>
  group_by(groups_c) |>
  summarise(authors = n_distinct(author_id),
            publications = n_distinct(eid)) |>
  mutate(group_label = case_when(
    groups_c == '0' ~ 'Single article',
    groups_c == '1' ~ 'Non-migrant',
    groups_c == '2' ~ 'Immigrant',
    groups_c == '3' ~ 'Emigrant',
    groups_c == '4' ~ 'Returning migrant',
    TRUE ~ 'Transient migrant'
  )) |>
  mutate(freq = (authors/sum(authors) * 100)) |>
  paged_table()
```

**(3) Average number of publications by group**

```{r}
#| warning: false
#| message: false
data_proj |>
  group_by(groups_c) |>
  select(author_id, eid) |>
  summarise(
    n_publication = n_distinct(eid),
    n_authors = n_distinct(author_id),
    average_articles = n_publication/n_authors
  ) |>
  mutate(group_label = case_when(
    groups_c == '0' ~ 'Single article',
    groups_c == '1' ~ 'Non-migrant',
    groups_c == '2' ~ 'Immigrant',
    groups_c == '3' ~ 'Emigrant',
    groups_c == '4' ~ 'Returning migrant',
    TRUE ~ 'Transient migrant'
  )) |>
  paged_table()
```

**(4) Citation statistics by group**

```{r}
data_proj |>
  distinct(eid, groups_c, citedby_count) |>
  group_by(groups_c) |>
  summarise(mean_citation = mean(citedby_count),
            median_citation = median(citedby_count),
            min_citation = min(citedby_count),
            max_citation = max(citedby_count),
            sd_citation = sd(citedby_count)) |>
  mutate(group_label = case_when(
    groups_c == '0' ~ 'Single article',
    groups_c == '1' ~ 'Non-migrant',
    groups_c == '2' ~ 'Immigrant',
    groups_c == '3' ~ 'Emigrant',
    groups_c == '4' ~ 'Returning migrant',
    TRUE ~ 'Transient migrant'
  )) |>
  paged_table()
```

**(5) SJR statistics by group**

```{r}
data_proj |>
  distinct(eid, groups_c, SJR) |>
  group_by(groups_c) |>
  summarise(mean_SJR = mean(SJR, na.rm = T),
            median_SJR = median(SJR, na.rm = T),
            min_SJR = min(SJR, na.rm = T),
            max_SJR = max(SJR, na.rm = T),
            sd_SJR = sd(SJR, na.rm = T)) |>
  mutate(group_label = case_when(
    groups_c == '0' ~ 'Single article',
    groups_c == '1' ~ 'Non-migrant',
    groups_c == '2' ~ 'Immigrant',
    groups_c == '3' ~ 'Emigrant',
    groups_c == '4' ~ 'Returning migrant',
    TRUE ~ 'Transient migrant'
  )) |>
  paged_table()
```

**(6) Top 10 authors with more publication**

```{r}
data_proj |>
  group_by(author_id, groups_c) |>
  summarise(n_pub = n_distinct(eid)) |>
  arrange(desc(n_pub)) |>
  paged_table()
```

**(7) Mean of citation by author**

```{r}
#| warning: false
#| message: false
data_proj |>
  group_by(author_id, groups_c) |>
  summarise(
    media_citacoes = mean(citedby_count, na.rm = TRUE),
    num_artigos = n_distinct(eid)) |>
  arrange(desc(media_citacoes)) |>
  head(100) |>
  paged_table()
```

**(8) Mean of SJR by author**

```{r}
#| warning: false
#| message: false
data_proj |>
  group_by(author_id, groups_c) |>
  summarise(
    media_sjr = mean(SJR, na.rm = TRUE),
    num_artigos = n_distinct(eid)) |>
  arrange(desc(media_sjr)) |>
  head(100) |>
  paged_table()
```

**(9) Citations for Return migrant**

```{r}
data_proj |>
  filter(groups_c %in% c(4)) |>
  ggplot(aes(x = as.factor(publication_year), y = cit_standard)) +
  geom_boxplot(fill = "lightblue", color = "darkblue", outlier.color = "red",
               outlier.size = 2) +
  labs(x = "Publication Year",
        y = "Citations") +
  theme_classic()
```

**(10) SJR for Return migrant**

```{r}
data_proj |>
  filter(groups_c %in% c(4)) |>
  ggplot(aes(x = as.factor(publication_year), y = SJR)) +
  geom_boxplot(fill = "lightblue", color = "darkblue", outlier.shape = NA) +
  labs(x = "Publication Year",
        y = "SJR") +
    scale_y_continuous(limits = c(0, 3)) +  # Ajusta o eixo Y
  theme_classic()
```

## Pesquisadores por subárea do conhecimento

-   **Distribution of publications by classification area:**

```{r}
data_proj |> 
  distinct(eid, DENT, HEAL, IMMU, MEDI, MULT, NEUR, NURS, PHAR, VETE) |>
  summarise(dent = sum(DENT, na.rm = T),
            heal = sum(HEAL, na.rm = T),
            immu = sum(IMMU, na.rm = T),
            medi = sum(MEDI, na.rm = T),
            mult = sum(MULT, na.rm = T),
            neur = sum(NEUR, na.rm = T),
            nurs = sum(NURS, na.rm = T),
            phar = sum(PHAR, na.rm = T),
            vete = sum(VETE, na.rm = T), 
            n = n())
```

```{r}
areas <- c("DENT", "HEAL", "IMMU", "MEDI", "MULT", "NEUR", "NURS", "PHAR", "VETE", "AGRI", "BIOC")

# Inicializar uma lista para armazenar os resultados
results_list <- list()

# Loop sobre as áreas
for (area in areas) {
  result <- data_proj |>
    filter(!!sym(area) == 1) |>  # Filtra pela área atual
    group_by(groups_c) |>
    summarise(
      mean_citation = round(mean(cit_standard), 2),
      sd_citation = round(sd(cit_standard), 2),
      mean_sjr = round(mean(SJR, na.rm = TRUE), 2),
      sd_sjr = round(sd(SJR, na.rm = TRUE), 2),
      n_articles = n_distinct(eid),
      n = n_distinct(author_id)
    ) |> 
    mutate(
      group_label = case_when(
        groups_c == '0' ~ 'Single article',
        groups_c == '1' ~ 'Non-migrant',
        groups_c == '2' ~ 'Immigrant',
        groups_c == '3' ~ 'Emigrant',
        groups_c == '4' ~ 'Returning migrant',
        TRUE ~ 'Transient migrant'
      ),
      area = area  # Adicionar o nome da área
    )
  
  # Adicionar à lista de resultados
  results_list[[area]] <- result
}

# Combinar os resultados em um único data frame
final_result <- bind_rows(results_list)

# Ver os resultados
final_result |> 
  filter(area == "MULT") |>
  view()

final_result |>
  select(group_label, area, n) |> kable()

final_result$group_reclassified <- ifelse(final_result$group_label == "Non-migrant", "Non-migrant", "Migrant")

final_result |>
  filter(group_label != c("Single article")) |>
  ggplot(aes(x = area, y = n, fill = group_reclassified)) +
  geom_bar(stat = "identity") + # , position = "fill"
  scale_fill_grey() +
  #scale_y_continuous(labels = scales::percent) + # Escala em porcentagem
  labs(
    x = "",
    y = "# researchers",
    fill = ""
  ) +
  theme_classic() +
  theme(
    legend.position = "bottom", # Legenda na parte inferior
    axis.text.x = element_text(angle = 0, hjust = 0.5) # Rotação no eixo X
  )


# media de citacoes 
data_grouped <- final_result %>%
  group_by(area, group_reclassified) %>%
  summarise(mean_citation = mean(mean_citation), 
            mean_sjr = mean(mean_sjr),
            .groups = "drop")

# Criar o gráfico de barras agrupadas
ggplot(data_grouped, aes(x = area, y = mean_citation, fill = group_reclassified)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  scale_fill_manual(values = c("Non-migrant" = "gray", "Migrant" = "black")) +
  labs(
    x = "",
    y = "Mean Citation",
    fill = ""
  ) +
  theme_classic() +
  theme(
    legend.position = "bottom"
  )

ggplot(data_grouped, aes(x = area, y = mean_sjr, fill = group_reclassified)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  scale_fill_manual(values = c("Non-migrant" = "gray", "Migrant" = "black")) +
  labs(
    x = "",
    y = "Mean SJR",
    fill = ""
  ) +
  theme_classic() +
  theme(
    legend.position = "bottom"
  )

```

```{r}
data_proj |>
  filter(MEDI == 1) |>
  ggplot(aes(x = as.factor(publication_year), y = cit_standard)) +
  geom_boxplot(fill = "lightblue", color = "darkblue", outlier.color = "red",
               outlier.size = 2) +
  labs(x = "Publication Year",
        y = "Citations") +
  theme_classic()
```

## Maps: Emigrant

```{r}
#| eval: false
#| echo: false
# 3.  Map of the researchers' migratory movements (based on sample)
# STEP 3-----------------------------------------------------------------------------------

# separet_longer_delim
# mapas para grupo return colocar para onde vai

df <- data_proj |>
  #filter(MEDI == 1) |> # por area
  arrange(author_id, publication_year) |>
  filter(!is.na(country_year_pub)) |> # drop group 0
  filter(groups_c == "3") |>
  group_by(author_id) |>
  summarise(
    first_country = first(country_year_pub),
    last_country = last(country_year_pub)
  ) |>
  ungroup() 

df <- df |>
  mutate(last_country = case_when(
    last_country == "Czech Republic" ~ "Czech Rep.",
    last_country == "Russian Federation" ~ "Russia",
    last_country == "South Korea" ~ "S. Korea",
    last_country == "Dominican Republic" ~ "Dominican Rep.",
    last_country == "Viet Nam" ~ "Vietnam",
    last_country == "Bosnia and Herzegovina" ~ "Bosnia and Herz.",
    last_country == "Brunei Darussalam" ~ "Brunei",
    TRUE ~ last_country)) |>
  filter(last_country != "" & !is.na(last_country))


library(rworldmap)
library(geosphere)

# Obter os dados de mapa
data(countriesLow)

# Extrair latitude e longitude médias de cada país
coords <- countriesLow@data %>%
  dplyr::transmute(country = NAME, lat = LAT, lon = LON)

all_pairs <- df |>
  left_join(coords, join_by(first_country == country)) |>
  left_join(coords, join_by(last_country == country)) |>
  filter(first_country == "Brazil")

all_pairs$author_id <- NULL

colnames(all_pairs) <- c("i_country", "f_country","lat1","long1","lat2","long2")

all_pairs |>
  count(i_country, f_country) |>
  arrange(desc(n))

df_freq <- all_pairs %>%
  count(i_country, f_country, name = "frequency") %>%
  arrange(desc(frequency))

# Juntar de volta na base original (opcional)
df_with_frequency <- all_pairs %>%
  left_join(df_freq, by = c("i_country", "f_country")) |>
  distinct()

all_pairs <- df_with_frequency

library(maps)
# background map
par(mar=c(0,0,0,0))
map('world',col="gray", fill=T, bg="white", lwd=0.5,mar=rep(0,4),border=0, ylim=c(-80,80) ) # #f2f2f2

max_lwd <- 4 # Ajuste conforme necessário

# Add connections with line thickness proportional to frequency
for(i in 1:nrow(all_pairs)){
  # Ajusta a espessura com base na frequência, normalizando para o intervalo de 1 a max_lwd
  line_width <- 0.2 + (all_pairs$frequency[i] / max(all_pairs$frequency)) * (max_lwd - 1)
  plot_my_connection(all_pairs$long1[i], all_pairs$lat1[i], all_pairs$long2[i], all_pairs$lat2[i], col = "navy", lwd = line_width)
}

# add every connections:
for(i in 1:nrow(all_pairs)){
  plot_my_connection(all_pairs$long1[i], all_pairs$lat1[i], all_pairs$long2[i], all_pairs$lat2[i], col="skyblue", lwd=1)
}


# A function to plot connections
plot_my_connection=function( dep_lon, dep_lat, arr_lon, arr_lat, ...){
  inter <- gcIntermediate(c(dep_lon, dep_lat), c(arr_lon, arr_lat), n=50, addStartEnd=TRUE, breakAtDateLine=F)             
  inter=data.frame(inter)
  diff_of_lon=abs(dep_lon) + abs(arr_lon)
  if(diff_of_lon > 180){
    lines(subset(inter, lon>=0), ...)
    lines(subset(inter, lon<0), ...)
  }else{
    lines(inter, ...)
  }
}

# Tipo 2 de mapa
color_palette <- colorRampPalette(c("lightblue", "blue", "darkblue"))(100)
all_pairs$color <- color_palette[cut(all_pairs$frequency, breaks = 100, labels = FALSE)]

# Configurações do mapa de fundo
par(mar = c(0, 0, 0, 0))
map("world", col = "#f2f2f2", fill = TRUE, bg = "white", lwd = 0.5, mar = rep(0, 4), border = 0, ylim = c(-80, 80))

# Adiciona cada conexão com cor correspondente à frequência
for (i in 1:nrow(all_pairs)) {
  plot_my_connection(
    all_pairs$long1[i], all_pairs$lat1[i],
    all_pairs$long2[i], all_pairs$lat2[i],
    col = all_pairs$color[i], lwd = 2
  )
}

# Função para plotar conexões
plot_my_connection <- function(dep_lon, dep_lat, arr_lon, arr_lat, ...) {
  inter <- gcIntermediate(c(dep_lon, dep_lat), c(arr_lon, arr_lat), n = 50, addStartEnd = TRUE, breakAtDateLine = FALSE)
  inter <- data.frame(inter)
  diff_of_lon <- abs(dep_lon) + abs(arr_lon)
  if (diff_of_lon > 180) {
    lines(subset(inter, lon >= 0), ...)
    lines(subset(inter, lon < 0), ...)
  } else {
    lines(inter, ...)
  }
}

# Adicionar uma legenda de cores para a escala de frequência
legend("bottomright", legend = c("Low", "Medium", "High"), 
       fill = color_palette[c(1, 50, 100)], title = "Frequency")

all_pairs |>
  filter(i_country == "Brazil") |>
  select(i_country, f_country) |>
  distinct() |> view()
```

## Maps: Return migrant

```{r}
#| eval: false
#| echo: false
# 3.  Map of the researchers' migratory movements (based on sample)
# STEP 3-----------------------------------------------------------------------------------

# separet_longer_delim
# mapas para grupo return colocar para onde vai

df_4 <- data_proj |>
  arrange(author_id, publication_year) |>
  filter(!is.na(country_year_pub)) |> # drop group 0
  filter(groups_c == "4") |>
  group_by(author_id) |>
  mutate(
    first_country = first(country_year_pub),
    first_change_country = country_year_pub[which(country_year_pub != first(country_year_pub))[1]]
  ) |>
  summarise(
    first_country = first(first_country),
    first_change_country = first(na.omit(first_change_country)) # Remove valores NA se não houver mudanças
  )

df_4 <- df_4 |>
  mutate(first_change_country = case_when(
    first_change_country == "Czech Republic" ~ "Czech Rep.",
    first_change_country == "Russian Federation" ~ "Russia",
    first_change_country == "South Korea" ~ "S. Korea",
    first_change_country == "Dominican Republic" ~ "Dominican Rep.",
    first_change_country == "Viet Nam" ~ "Vietnam",
    first_change_country == "Bosnia and Herzegovina" ~ "Bosnia and Herz.",
    first_change_country == "Brunei Darussalam" ~ "Brunei",
    TRUE ~ first_change_country  # Mantém os valores originais para os que não correspondem
  )) |>
  filter(first_change_country != "" & !is.na(first_change_country))

all_pairs_4 <- df_4 |>
  left_join(coords, join_by(first_country == country)) |>
  left_join(coords, join_by(first_change_country == country)) |>
  filter(first_country == "Brazil")

all_pairs_4$author_id <- NULL

colnames(all_pairs_4) <- c("i_country", "f_country","lat1","long1","lat2","long2")

# all_pairs_4 |>
#   count(i_country, f_country) |>
#   arrange(desc(n))

df_freq_4 <- all_pairs_4 %>%
  count(i_country, f_country, name = "frequency") %>%
  arrange(desc(frequency))

# Juntar de volta na base original (opcional)
df_with_frequency_4 <- all_pairs_4 %>%
  left_join(df_freq_4, by = c("i_country", "f_country")) |>
  distinct()

all_pairs_4 <- df_with_frequency_4


library(maps)
# background map
par(mar=c(0,0,0,0))
map('world',col="gray", fill=T, bg="white", lwd=0.5,mar=rep(0,4),border=0, ylim=c(-80,80) ) # #f2f2f2

max_lwd <- 4 # Ajuste conforme necessário

# Add connections with line thickness proportional to frequency
for(i in 1:nrow(all_pairs_4)){
  # Ajusta a espessura com base na frequência, normalizando para o intervalo de 1 a max_lwd
  line_width <- 0.2 + (all_pairs_4$frequency[i] / max(all_pairs_4$frequency)) * (max_lwd - 1)
  plot_my_connection(all_pairs_4$long1[i], all_pairs_4$lat1[i], all_pairs_4$long2[i], all_pairs_4$lat2[i], col = "navy", lwd = line_width)
}

# add every connections:
for(i in 1:nrow(all_pairs_4)){
  plot_my_connection(all_pairs_4$long1[i], all_pairs_4$lat1[i], all_pairs_4$long2[i], all_pairs_4$lat2[i], col="skyblue", lwd=1)
}

# add points and names of cities
# points(x=all_pairs$long1, y=all_pairs$lat1, col="slateblue", cex=2, pch=20)
# text(rownames(all_pairs), x=all_pairs$long2, y=all_pairs$lat2,  col="slateblue", cex=1, pos=4)

# A function to plot connections
plot_my_connection=function( dep_lon, dep_lat, arr_lon, arr_lat, ...){
  inter <- gcIntermediate(c(dep_lon, dep_lat), c(arr_lon, arr_lat), n=50, addStartEnd=TRUE, breakAtDateLine=F)             
  inter=data.frame(inter)
  diff_of_lon=abs(dep_lon) + abs(arr_lon)
  if(diff_of_lon > 180){
    lines(subset(inter, lon>=0), ...)
    lines(subset(inter, lon<0), ...)
  }else{
    lines(inter, ...)
  }
}

# Tipo 2 de mapa
color_palette <- colorRampPalette(c("lightblue", "blue", "darkblue"))(100)
all_pairs_4$color <- color_palette[cut(all_pairs_4$frequency, breaks = 100, labels = FALSE)]

# Configurações do mapa de fundo
par(mar = c(0, 0, 0, 0))
map("world", col = "#f2f2f2", fill = TRUE, bg = "white", lwd = 0.5, mar = rep(0, 4), border = 0, ylim = c(-80, 80))

# Adiciona cada conexão com cor correspondente à frequência
for (i in 1:nrow(all_pairs_4)) {
  plot_my_connection(
    all_pairs_4$long1[i], all_pairs_4$lat1[i],
    all_pairs_4$long2[i], all_pairs_4$lat2[i],
    col = all_pairs_4$color[i], lwd = 2
  )
}

# Função para plotar conexões
plot_my_connection <- function(dep_lon, dep_lat, arr_lon, arr_lat, ...) {
  inter <- gcIntermediate(c(dep_lon, dep_lat), c(arr_lon, arr_lat), n = 50, addStartEnd = TRUE, breakAtDateLine = FALSE)
  inter <- data.frame(inter)
  diff_of_lon <- abs(dep_lon) + abs(arr_lon)
  if (diff_of_lon > 180) {
    lines(subset(inter, lon >= 0), ...)
    lines(subset(inter, lon < 0), ...)
  } else {
    lines(inter, ...)
  }
}

# Adicionar uma legenda de cores para a escala de frequência
legend("bottomright", legend = c("Low", "Medium", "High"), 
       fill = color_palette[c(1, 50, 100)], title = "Frequency")
```

## Comparison pre and post academic mobility (emigrant)

To perform the comparison between the authors' pre- and post-academic mobility periods, the year of the first change of country was first found.

![](example-author.png){width="500"}

First, graphs were made for the **number of citations** and the **SJR index** without any transformation of the variable.

```{r}
#| warning: false
#| message: false
# Date when migration happens
df_g3 <- data_proj |>
  filter(groups_c == "3") |> 
  arrange(author_id, publication_year) |>
  group_by(author_id) |>
  mutate(previous_country = lag(country_year_pub, order_by = publication_year)) |>
  mutate(change_year = if_else(country_year_pub != previous_country & !is.na(previous_country), publication_year, NA_real_)) |>
  group_by(author_id) |>
  mutate(first_change_year = min(change_year, na.rm = TRUE)) |>
  ungroup() |>
  mutate(period = if_else(publication_year < first_change_year, "Before Change", "After Change")) |>
  select(-previous_country, -change_year) |>
  filter(first_change_year %in% c(2010:2015)) # coment

ggplot(df_g3, aes(x = publication_year, y = citedby_count)) + # citedby_count
  geom_point(aes(color = period)) +
  geom_vline(aes(xintercept = first_change_year), linetype = "dashed", color = "black") +
  scale_color_manual(values = c("Before Change" = "black", "After Change" = "red")) +
  labs(
    x = "Publication year",
    y = "Number of citation",
    color = ""
  ) +
  facet_wrap(~ first_change_year, scales = "free_x") +
  theme_classic() +
  theme(legend.position = "bottom")


ggplot(df_g3, aes(x = publication_year, y = SJR)) + 
  geom_point(aes(color = period)) +
  geom_vline(aes(xintercept = first_change_year), linetype = "dashed", color = "black") +
  scale_color_manual(values = c("Before Change" = "black", "After Change" = "red")) +
  labs(
    x = "Publication year",
    y = "SJR index",
    color = ""
  ) +
  facet_wrap(~ first_change_year, scales = "free_x") +
  theme_classic() +
  theme(legend.position = "bottom")

```

The 99th percentile was then winsorized, which means that any value above the 99th percentile was replaced by the value corresponding to the 99th percentile [(Aykac, 2021)](https://link.springer.com/article/10.1007/s11192-021-04052-4#Abs1).

```{r}
#| warning: false
#| message: false
# Aplicar a winsorização por ano
df_g3_1 <- df_g3 %>%
  group_by(publication_year) %>%
  mutate(citations_winsorized = Winsorize(cit_standard, probs = c(0, 0.99)))

ggplot(df_g3_1, aes(x = publication_year, y = citations_winsorized)) + 
  geom_point(aes(color = period)) +
  geom_vline(aes(xintercept = first_change_year), linetype = "dashed", color = "black") +
  scale_color_manual(values = c("Before Change" = "black", "After Change" = "red")) +
  labs(
    x = "Publication year",
    y = "Number of citation",
    color = ""
  ) +
  facet_wrap(~ first_change_year, scales = "free_x") +
  theme_classic() +
  theme(legend.position = "bottom")

```

## Comparison pre and post academic mobility (returning migrant)

```{r}
#| warning: false
#| message: false
# Date when migration happens
df_g4 <- data_proj |>
  filter(groups_c == "4") |> 
  arrange(author_id, publication_year) |>
  group_by(author_id) |>
  mutate(previous_country = lag(country_year_pub, order_by = publication_year)) |>
  mutate(change_year = if_else(country_year_pub != previous_country & !is.na(previous_country), publication_year, NA_real_)) |>
  group_by(author_id) |>
  mutate(first_change_year = min(change_year, na.rm = TRUE)) |>
  ungroup() |>
  mutate(period = if_else(publication_year < first_change_year, "Before Change", "After Change")) |>
  select(-previous_country, -change_year) |>
  filter(first_change_year %in% c(2010:2015)) # coment

ggplot(df_g4, aes(x = publication_year, y = citedby_count)) + # citedby_count
  geom_point(aes(color = period)) +
  geom_vline(aes(xintercept = first_change_year), linetype = "dashed", color = "black") +
  scale_color_manual(values = c("Before Change" = "black", "After Change" = "red")) +
  labs(
    x = "Publication year",
    y = "Number of citation",
    color = ""
  ) +
  facet_wrap(~ first_change_year, scales = "free_x") +
  theme_classic() +
  theme(legend.position = "bottom")


ggplot(df_g4, aes(x = publication_year, y = SJR)) + 
  geom_point(aes(color = period)) +
  geom_vline(aes(xintercept = first_change_year), linetype = "dashed", color = "black") +
  scale_color_manual(values = c("Before Change" = "black", "After Change" = "red")) +
  labs(
    x = "Publication year",
    y = "SJR index",
    color = ""
  ) +
  facet_wrap(~ first_change_year, scales = "free_x") +
  theme_classic() +
  theme(legend.position = "bottom")

```

The 99th percentile was then winsorized, which means that any value above the 99th percentile was replaced by the value corresponding to the 99th percentile [(Aykac, 2021)](https://link.springer.com/article/10.1007/s11192-021-04052-4#Abs1).

```{r}
#| warning: false
#| message: false
# Real Data
# Aplicar a winsorização por ano
df_g4_1 <- df_g4 %>%
  group_by(publication_year) %>%
  mutate(citations_winsorized = Winsorize(cit_standard, probs = c(0, 0.99)))

ggplot(df_g4_1, aes(x = publication_year, y = citations_winsorized)) + 
  geom_point(aes(color = period)) +
  geom_vline(aes(xintercept = first_change_year), linetype = "dashed", color = "black") +
  scale_color_manual(values = c("Before Change" = "black", "After Change" = "red")) +
  labs(
    x = "Publication year",
    y = "Number of citation",
    color = ""
  ) +
  facet_wrap(~ first_change_year, scales = "free_x") +
  theme_classic() +
  theme(legend.position = "bottom")

```

```{r}
#| eval: false
#| echo: false
# Other questions:
# what are the most cited articles per year?
```

## Analysis per country

-   Separar os pesquisadores com destino nos EUA, Canadá e Reino Unido
-   Número de citações e fator de impacto médio (série temporal por país)
-   Comparar esses resultados com quem nunca saiu do Brasil

```{r}
# last country by author
top3 <- data_final_up |>
  arrange(author_id, publication_year) |>
  group_by(author_id) |>
  filter(groups_c == "3") |> # or != 0
  summarise(
    last_country = last(country_year_pub)
  ) |>
  ungroup() |>
  filter(last_country %in% c("United States", "Canada", "United Kingdom")) |>
  select(author_id) |>
  as.list()

data_top3 <- data_final_up |>
  filter(author_id %in% top3[["author_id"]])
```

```{r}
# media de citacao e sjr para os pesquisadores que foram para os EUA, UK ou Canada
data_top3 <- data_top3 |>
  group_by(publication_year) |>
  summarise(citation = mean(cit_standard),
            sjr = mean(SJR, na.rm = TRUE)) |>
  mutate(group = "Top 3")

data_final_up_group1 <- data_final_up |>
  filter(groups_c == "1") |>
  group_by(publication_year) |>
  summarise(citation = mean(cit_standard),
            sjr = mean(SJR, na.rm = TRUE)) |>
  mutate(group = "Never Left Brazil")

# Combinando os dois dataframes
combined_data <- bind_rows(data_top3, data_final_up_group1)

# Criando o gráfico combinado
ggplot(combined_data) +
  geom_bar(aes(x = publication_year, y = sjr, fill = group), 
           stat = "identity", position = "dodge", alpha = 0.7) +  
  geom_line(aes(x = publication_year, y = citation, color = group, group = group), 
            size = 1.5) +
  labs(x = "Publication Year", 
       y = "SJR",
       fill = "Group", 
       color = "Group") +
  scale_y_continuous(sec.axis = sec_axis(~.*1, name = "Citation")) +
  theme_classic() +
  theme(legend.position = "top")
```

